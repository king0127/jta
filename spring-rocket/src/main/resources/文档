
RocketMQ
---------------------------------------------最终一致性---------------------------------------------------------
MQ分布式事务的执行流程：
1. 服务A发送一个半事务消息（half消息）到MQ中；
2. 如果half消息发送成功，MQ收到这个half事务消息后，会返回给服务A一个success响应
3. 服务A接受到MQ返回的success响应后，开始处理本地事务逻辑，并提交本地事务；
4. 如果服务A本地事务提交成功，则会向MQ发送commit，表示将half消息提交；
如果服务A本地事务提交失败，则直接回滚本地事务，并向MQ发送rollback，将之前half消息进行回滚，MQ接受到rollback消息后，会将half消息删除
5. 如果commit，会将half消息写入磁盘
6. 如果MQ长时间没有接受到commit或者rollback消息，MQ会在一定时间后尝试调用服务A的接口，通过改接口判断half消息的状态
（服务A接口：实现逻辑通过数据库中对应数据的状态来判断，half消息对应的业务是否执行完成，如果执行成功将half消息持久化本地磁盘； 没有执行成功，则将half消息删除）
7. 服务B消息MQ消息
8. 服务B处理本地业务逻辑，然后提交本地事务


上述2-4步骤执行解析：
服务A发送一个半事务消息后，MQ通过监听该消息先检测该半消息发送者服务A本地事务的状态，
如果提交了本地事务MQ将half写入磁盘，并commit半消息事务；
如果是UNKNOWN，MQ将会在一定时间后检测本地事务的状态，如果提交commit就将half写入磁盘，并提交


关键词解析：
1. rocketMQ实现分布式事务【最终一致性】
    - 半消息： 是指暂不能被Consumer消费的消息。
    Producer 已经把消息成功发送到了 Broker 端，但此消息被标记为暂不能投递状态，处于该种状态下的消息称为半消息。需要 Producer
    对消息的二次确认后，Consumer才能去消费它。

    - 消息回查： 由于网络闪段，生产者应用重启等原因。导致 Producer 端一直没有对 Half Message(半消息) 进行 二次确认。
    这是Brock服务器会定时扫描长期处于半消息的消息，会主动询问 Producer端 该消息的最终状态(Commit或者Rollback),该消息即为 消息回查。

2. 问题案例解析：
    只有本地服务事务执行成功 ，消费者服务才能消费该message，并向下执行；【理解就是，入口本地方法的事务执行成功后，MQ消费者才能消费到消息处理】
    -- 如果本地服务的事务失败了， 那么消息是不会被消费到的；
    -- 如果本地事务成功了， 但是消费端在消费的过程中出现了失败， 那么程序上就不能实现代码的回滚操作了， 需要将错误的信息记录下， 人工处理【人工兜底】
    例如服务B对应得DB宕机了，这个时候只要服务B不像MQ提交本次消息得offset,那么MQ会在一定时间后，继续将这条消息推送给服务B，服务就可以继续执行本地事务并提交了
    直到成功。这样保证数据得最终一致性。
    **抛砖： 如果保证消息不丢失？是最重要问题**

3. 如果服务A本地事务提交失败了？？
    服务A本地事务提交失败，直接回滚，向MQ的half发送rollback

总结：
    针对MQ的最终一致性方案，其实就把控了 消费端什么时候消费消息的问题， 如果消费端出现了异常了，只能手动人工处理；【半智能化】

    - 使用场景：
        1. 业务简单。服务交叉不复杂的情况下使用；
        2. 如果消费端的业务量特别复杂，一旦出现报错了，那就..... 累死狗了

    缺点：
        每次消息发送都需要两次请求；
        业务处理系统，需要提供业务状态接口；


---------------------------------------------消息不丢失---------------------------------------------------------
上述在解析MQ最终一致性问题时提到过，怎么保证MQ消息不丢失问题：
解析下MQ消息丢失的场景有哪些：
1. 生产者发送消息到MQ时，出现网络抖动或者通信异常，导致消息丢失；
2. 消息发送到MQ后，消息持久化到磁盘中，导致消息丢失：
    2.1 MQ为了减少磁盘的IO,会先将消息写入到os cache中，而不是直接写入到磁盘中，消费者从os cache中获取消息，过一段时候后os线程会
    异步将消息刷到磁盘中，才算完成消息的持久化。 在这个过程中如果MQ的 brock宕机了，就会导致消息的丢失
    2.2 如果消息已经刷到磁盘中，但是还没来得及做任何备份，一旦磁盘损害，那么消息也会丢失 (引入问题：磁盘损坏的场景有那些？？？)
3. 消费者成功从MQ中获取到消息，但是消息还没完全消费完，就通知MQ已经将消息消费了，然后消费者宕机了，这种情况消息也会丢失



解决方案：
1. 第一种消息丢失场景:生产者在向MQ发送消息的时候采用同步发送消息，或者事务发送半消息即可解决这类问题。
   同步MQ消息，MQ在接收到消息之后会给接口返回一个success或者rollback响应，确保MQ已经接收到消息或者未接收到消息；
   事务MQ消息，接口调用事务消息会向MQ发送一个半消息half，如果half消息发送成功，会向接口返回一个success响应；
2. 第二种场景有两种丢失消息的：
    2.1 RocketMQ默认是异步将消息持久化写入磁盘，这里修改持久化刷盘方式即可：改成同步持久化数据
    2.2 RocketMQ采用主从架构，集群模式，可以降低磁盘损坏情况
3. RocketMQ消费者消息消费结束后，返回一个消除成功标识通知MQ消息成功即可。手动确认ACK

---------------------------------------------消息重复消费---------------------------------------------------------
解析消息重复消费的场景有哪些？
1. 生产者同一个消息发送多次；
2. 消费者同一个消息被消费多次；

针对重复消费的解决方案：
1. 针对生产者同一个消息发送多次场景，根据业务场景处理。 例如： 某商城的订单下单功能，方案设计思路： 商品下单-扣减库存后，当买家确认收货后扣取金额：
这里采用当买家确认收获后，通过MQ异步扣取订单金额。 该场景可在发送扣取金额MQ之前根据订单编号查询当前订单的物流状态是否为已收货， 如果已收货则不在发送MQ， 否则发送MQ

2. 消费者同一个消息被消费多次场景：
    a. 可通过MYSQL一张记录表，每次消费者消费的消息都记录在该表中，通过消息体中的唯一标识来做消息唯一性的识别，该消息是否已经被消费过（适用于单服务，并发小的系统中）
    b. 通过redis的zset记录唯一标识key,判断该消息是否被消费过

---------------------------------------------消息挤压怎么处理---------------------------------------------------------
共识知识点：

RocketMQ消息被消费后，消息会立即被删除吗？
当然不会。 MQ的每一个消息都会被持久化到磁盘中，消息记录在CommitLog中，被消费后消息并不会被立即被删除，只会修改CommitLog的offset偏移量进度。

RocketMQ的消息会永久保存在磁盘上？
不是。 默认消息持久化在磁盘上48小时。RocketMQ会监控消息的消费时间，如果48小时没有消费过该消息就会被删除。

那么如果消息被大量挤压怎么处理？？？

挤压消息的数量
单个topic消费者的消费流量
多个topic
队列大小


